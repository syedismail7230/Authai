// AI Analysis Service using Google Gemini
import { GoogleGenerativeAI } from '@google/generative-ai';

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || 'demo-key');

/**
 * Analyze text content for AI generation detection
 */
export async function analyzeText(content) {
    try {
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        const prompt = `Analyze the following text and determine if it was likely generated by AI. 
        Provide a confidence score (0-100) and reasoning.
        
        Text to analyze:
        "${content.substring(0, 5000)}"
        
        Respond in JSON format:
        {
            "isAIGenerated": boolean,
            "confidence": number (0-100),
            "reasoning": string,
            "indicators": string[]
        }`;
        
        const result = await model.generateContent(prompt);
        const response = await result.response;
        const text = response.text();
        
        // Parse JSON response
        const analysis = JSON.parse(text.replace(/```json\n?|\n?```/g, ''));
        
        return {
            verdict: analysis.isAIGenerated ? 'AI_GENERATED' : 'HUMAN_CREATED',
            confidence: analysis.confidence,
            aiProbability: analysis.confidence / 100,
            reasoning: analysis.reasoning,
            indicators: analysis.indicators,
            model: 'gemini-pro',
            timestamp: new Date().toISOString()
        };
    } catch (error) {
        console.error('Gemini API Error:', error);
        // Fallback to heuristic analysis
        return fallbackTextAnalysis(content);
    }
}

/**
 * Analyze image for AI generation/manipulation
 */
export async function analyzeImage(base64Image) {
    try {
        const model = genAI.getGenerativeModel({ model: "gemini-pro-vision" });
        
        const prompt = `Analyze this image for signs of AI generation or manipulation. 
        Look for: artifacts, unnatural patterns, inconsistencies, deepfake indicators.
        
        Respond in JSON format:
        {
            "isAIGenerated": boolean,
            "confidence": number (0-100),
            "reasoning": string,
            "indicators": string[]
        }`;
        
        const imageParts = [{
            inlineData: {
                data: base64Image.split(',')[1],
                mimeType: "image/jpeg"
            }
        }];
        
        const result = await model.generateContent([prompt, ...imageParts]);
        const response = await result.response;
        const text = response.text();
        
        const analysis = JSON.parse(text.replace(/```json\n?|\n?```/g, ''));
        
        return {
            verdict: analysis.isAIGenerated ? 'AI_GENERATED' : 'AUTHENTIC',
            confidence: analysis.confidence,
            aiProbability: analysis.confidence / 100,
            reasoning: analysis.reasoning,
            indicators: analysis.indicators,
            model: 'gemini-pro-vision',
            timestamp: new Date().toISOString()
        };
    } catch (error) {
        console.error('Gemini Vision API Error:', error);
        return fallbackImageAnalysis(base64Image);
    }
}

/**
 * Fallback heuristic analysis when AI is unavailable
 */
function fallbackTextAnalysis(content) {
    const indicators = [];
    let aiProbability = 0;
    
    // Check for common AI patterns
    const aiPhrases = [
        'as an AI', 'I am an AI', 'language model', 'I cannot', 'I apologize',
        'furthermore', 'moreover', 'in conclusion', 'it is important to note'
    ];
    
    const lowerContent = content.toLowerCase();
    aiPhrases.forEach(phrase => {
        if (lowerContent.includes(phrase)) {
            aiProbability += 0.15;
            indicators.push(`Contains phrase: "${phrase}"`);
        }
    });
    
    // Check sentence structure uniformity
    const sentences = content.split(/[.!?]+/);
    const avgLength = sentences.reduce((sum, s) => sum + s.length, 0) / sentences.length;
    if (avgLength > 80 && avgLength < 120) {
        aiProbability += 0.1;
        indicators.push('Uniform sentence length (AI pattern)');
    }
    
    // Check for repetitive structure
    const words = content.split(/\s+/);
    const uniqueWords = new Set(words.map(w => w.toLowerCase()));
    const lexicalDiversity = uniqueWords.size / words.length;
    if (lexicalDiversity < 0.4) {
        aiProbability += 0.1;
        indicators.push('Low lexical diversity');
    }
    
    aiProbability = Math.min(aiProbability, 1);
    
    return {
        verdict: aiProbability > 0.5 ? 'AI_GENERATED' : 'HUMAN_CREATED',
        confidence: Math.round(aiProbability * 100),
        aiProbability,
        reasoning: 'Heuristic analysis based on linguistic patterns',
        indicators,
        model: 'heuristic-fallback',
        timestamp: new Date().toISOString()
    };
}

/**
 * Fallback image analysis
 */
function fallbackImageAnalysis(base64Image) {
    // Basic image metadata analysis
    const indicators = ['Metadata analysis', 'File structure check'];
    
    return {
        verdict: 'INCONCLUSIVE',
        confidence: 50,
        aiProbability: 0.5,
        reasoning: 'Basic analysis - AI vision model unavailable',
        indicators,
        model: 'metadata-fallback',
        timestamp: new Date().toISOString()
    };
}

/**
 * Comprehensive multi-modal analysis
 */
export async function analyzeContent(content, contentType) {
    const startTime = Date.now();
    
    let analysis;
    switch (contentType) {
        case 'TEXT':
            analysis = await analyzeText(content);
            break;
        case 'IMAGE':
            analysis = await analyzeImage(content);
            break;
        case 'AUDIO':
        case 'VIDEO':
            // For now, use text analysis on metadata
            analysis = fallbackTextAnalysis(`Audio/Video file analysis: ${content.substring(0, 200)}`);
            analysis.note = 'Advanced audio/video analysis coming soon';
            break;
        default:
            throw new Error('Unsupported content type');
    }
    
    const processingTime = Date.now() - startTime;
    
    return {
        ...analysis,
        contentType,
        contentHash: generateContentHash(content),
        processingTime: `${processingTime}ms`,
        metadata: {
            contentLength: content.length,
            analyzedAt: new Date().toISOString()
        }
    };
}

/**
 * Generate content hash for blockchain
 */
function generateContentHash(content) {
    const crypto = require('crypto');
    return crypto.createHash('sha256').update(content).digest('hex');
}

export default {
    analyzeText,
    analyzeImage,
    analyzeContent
};
